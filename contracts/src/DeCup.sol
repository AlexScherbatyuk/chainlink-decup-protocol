/*
*                                                                                                      
*                                                   █#░╠╠╫╣░░░░╣╣╫╫╠╠╫╫╫╠╠░#                           
*                                              █#░╠╫╣╣╣╣╣░▒▒▒▒░░░░░░░▒▒▒░░╣╫╠╠░#                       
*                                       █#░░░###░╠░░##░╫╣╫╫╫╠╠╠╠╫╫╠╫╫╣╣╣╣░╣╣░▒▒░╠▒▒╣#                  
*                                    █#░░░░#█####█████#░░░░░██###░░╫╫╫╠╠╠╫╣╣╣╣╫╠╫░░▒▒╫                 
*                                  █░╠╠░░░#██#███████░░###░░####░╠╫╫╫╫╫╫╫╫╣╣╣╣░╫╣░▒╣#╣░#               
*                              █░╫╫╣▒░╫####███████#╠╣╫╠#████░╠░░░##░╫░░░░░░╣╣╣░░░▓░▒▒░#╫╣╣░▒▒▒▒▒▒▒░░╠  
*                             #╠╫╫░░▒╠##░#███████#╫╫╠#████░░░###░░╠╣░░░░░░╣╫╫╣░░╫▓█╠╣▒╠██╫░░░░░░░░╫╠#  
*                            ╠╫╫╫░░╣░##░░#███###░╠╠#████#╠#█████#╫░░░╠╫░░╣╫╣╫╫░▒░╠██░╫░#╠╫░░░░▒▒▒▒░╣╠  
*                         #╫╣╣░▒▒╫████#█▓#░█#▓#█▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╠▒░╫#░╠╫╫╫╫╣░░▒░╠╠╫╣╣╣╣░░░░░░░╣╠#       
*                        #╫╣╣╣░▒▒░████##█#█▓▓▓▓▓▓█#█▓▓▓▓▓▓▓██▓█░╫░#░╠╫╫╫╣╣╣░░╣#█╫╫╠╫╫╫╫╣╣░╣░▒▒╣#       
*                        ╠╫▒╣╫▒▒▒░█████#█▓▓█#░█▓#░█▓▓█▓▓▓▓▓#╠█##╠░#█░╫╫╠╫╫╫░░░#░░╫╫╣╣╣░░▒▒▒░░▒▒░░      
*                      ░╠╫░░░╠╫░╣▒░████▓▓███▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓████##░░░░╠╣░╣╫░█░░░╠░░╠╣░░╣░▒▒▒░╣╣      
*                      ╫╠╫░╣░╣╠░╣╫╫#███▓▓▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓██████#╠#░╠░╠╫╠╫╣╫╫╣╣░█##╠╠░╠╫╣░▒▒░░░░░       
*                      ╫░╫░╣╣░╠╠╣╠╠░███#█▓██▓▓██▓▓████▓▓███████╠░╠╠╫╣╫╠╠╫╫╫╠░░╫██╠╫▒╫░╠╫╫╫╣▒░░░█       
*                      ╠╠╫░╣╣╫╣╫░░░#█████##█▓▓▓▓▓▓▓▓▓█##░╫╫░####░###░#█        ╫█#█▓#░░╫╣░░╫╠╫░█       
*                      ╠╠╫╫╣╫░╫░█###█████##█▓▓▓▓█▓█▓▓▓▓█░█╫░###██#██        #╫░░╠█▓###░╠╣░▒▒╫╫╫        
*                      ╫╣╠╫╣╠╣╣#█#██████#██▓▓▓▓▓▓██▓▓▓▓█#█##████▓         ░╣░░╣╠█▓█#██#╫░╣╫▒╣╠╣        
*                       ░▒╣╠╣╠╫#██████▓▓██▓██▓█▓▓▓██████▓▓           #╠╣╫╫╠╠╠╫╠█▓█╠╫#█░╣╠░#╠▒╠╠        
*                       #▒╣░╫╠╠#█##██▓▓▓██▓██▓██████▓▓            █░╠╠╠░░░░#╫╠░#▓#╫░#█#╣╫╠##╫╠╫        
*                        ░░░##╠░###████████████▓▓              ▓█#░░░##██░░█╠╠#█▓█░╫░█#╫╫╫╠╠╠╠╫        
*                           ▓█▓▓██▓▓▓▓▓              ▓▓███████████████#░░#█▓█╫╫╠█▓▓███##╠╣╫╠╣#         
*                                                ▓▓██████#██████████#░╠╠█▓█▓▓╠╣╫░█▓███#░░╠╫░░          
*                         ##                ▓▓███##███████▓▓████▓██#░░░░#▓▓█#░╣░╣╫#███##░╫░░╣          
*                          #╣░╫╣░╠░░░###████████████▓▓▓▓▓▓██▓▓██#█###░╠░##▓▓#╣░░░░░░░░░░░░╣▒╠          
*                           ╠╣╣╠╣╠#######████▓▓█████▓▓▓▓███████########█##▓▓█╠░░╣░░░░░░░╣╣╣░#          
*                            ╠░#╫╣#######██##█▓▓▓██▓▓▓██████###████████##█▓▓▓#╫╣╫╣╫╣╣╫╫╠░░█            
*                             ░░#╫╫#######████▓▓▓▓████████#█#█▓▓▓▓▓█▓▓███▓▓                            
*                              ░░░╣░######███#█████████████#█▓▓▓▓▓▓██▓▓▓                               
*                               ╠#╠╫#######██#█████████████#██▓▓▓▓▓▓▓                                  
*                                ╠╠░░#####█#███████###████▓▓                                           
*                                 ╠╠╠╠╠╠╠░░##██##████▓▓▓▓                                              
*                                   ██##########██▓▓▓▓                                                 
*/
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {Base64} from "@openzeppelin/contracts/utils/Base64.sol";
import {ERC721Burnable} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title Decentralized Cup of assets (DeCup)
 * @author Alexander Scherbatyuk
 * @notice Collaterized NFT (Cup of Assets) to be sold cross-chain as single NFT. Contract receives native currency and
 * a pre-defined number of ERC20 tokens as collateral.
 * @dev This contract utilizes:
 * - Chainlink Price Feeds to calculate NFT price based on assets market prices,
 * - Chainlink CCIP to populate transfer and burn functionalities cross-chain.
 */
contract DeCup is ERC721, ERC721Burnable, Ownable, ReentrancyGuard {
    // Errors
    error DeCup__AmountMustBeGreaterThanZero();
    error DeCup__TransferFailed();
    error DeCup__InsufficientBalance();
    error DeCup__NotAllowedToken();
    error DeCup__TokenAddressesAndPriceFeedAddressesMusBeSameLength();
    error DeCup__TokenAddressesAndAmountsMusBeSameLength();
    error DeCup__TokenDoesNotExist();
    error DeCup__AllowedTokenAddressesMustNotBeEmpty();
    error DeCup__PriceFeedAddressesMustNotBeEmpty();
    error DeCup__TokenIsListedForSale();
    error DeCup__TokenIsNotListedForSale();
    error DeCup__NotOwner();
    error DeCup__NotTokenOwner();
    error DeCup__NotOwnerOrManager();

    // State variables
    uint256 private s_tokenCounter;
    string private s_svgImageUri;
    string private s_defaultSymbol;

    uint256 private constant PRECISION_18 = 1e18;
    uint256 private constant PRECISION_8 = 1e8;
    uint256 private constant ETH_DECIMALS = 18;
    uint256 private constant ADDITIONAL_FEED_PRECISION = 1e10;
    uint256 private constant PRECISION_MULTIPLIER = 1e10;

    address private immutable s_defaultPriceFeed;

    mapping(uint256 tokenId => address[] assets) private s_tokenIdToAssets;
    mapping(address token => address priceFeed) private s_tokenToPriceFeed;
    mapping(uint256 tokenId => mapping(address token => uint256 amount)) private s_collateralDeposited;
    mapping(uint256 tokenId => bool isListedForSale) private s_tokenIdIsListedForSale;
    mapping(uint256 tokenId => uint256 chainId) private s_tokenIdIsListedForSaleOnChain;

    // Events
    event DepositNativeCurrency(address indexed from, uint256 indexed tokenId, uint256 amount);
    event DepositERC20Token(address indexed from, uint256 indexed tokenId, address indexed token, uint256 amount);
    event WithdrawNativeCurrency(address indexed to, uint256 amount);
    event WithdrawERC20Token(address indexed to, address indexed token, uint256 amount);
    event TokenListedForSale(uint256 indexed tokenId, uint256 indexed chainId);
    event TokenRemovedFromSale(uint256 indexed tokenId);
    event Burn(uint256 indexed tokenId);
    event TransferAndBurn(uint256 indexed tokenId);
    // Modifiers

    /**
     * @notice Modifier to check if the amount is greater than zero
     * @param amount The amount to check
     * @dev Reverts if the amount is zero
     */
    modifier moreThanZero(uint256 amount) {
        if (amount == 0) {
            revert DeCup__AmountMustBeGreaterThanZero();
        }
        _;
    }

    /**
     * @notice Modifier to check if the caller is the owner of the token
     * @param tokenId The ID of the token to check
     * @dev Reverts if the caller is not the owner of the token
     */
    modifier isOwner(uint256 tokenId) {
        if (ownerOf(tokenId) != msg.sender) {
            revert DeCup__NotTokenOwner();
        }
        _;
    }

    /**
     * @notice Modifier to check if the caller is the contract owner (manager)
     * @dev Reverts if the caller is not the contract owner
     */
    modifier isManager() {
        if (owner() != msg.sender) {
            revert DeCup__NotOwner();
        }
        _;
    }

    /**
     * @notice Modifier to check if the caller is the token owner or contract owner (manager)
     * @param tokenId The ID of the token to check
     * @dev Reverts if the caller is neither the token owner nor the contract owner
     */
    modifier isOwnerOrManager(uint256 tokenId) {
        if (ownerOf(tokenId) != msg.sender && owner() != msg.sender) {
            revert DeCup__NotOwnerOrManager();
        }
        _;
    }

    /**
     * @notice Modifier to check if the token is listed for sale
     * @param tokenId The ID of the token to check
     * @dev Reverts if the token is NOT listed for sale
     */
    modifier tokenIsListedForSale(uint256 tokenId) {
        if (!s_tokenIdIsListedForSale[tokenId]) {
            revert DeCup__TokenIsNotListedForSale();
        }
        _;
    }

    /**
     * @notice Modifier to check if the token is NOT listed for sale
     * @param tokenId The ID of the token to check
     * @dev Reverts if the token IS listed for sale
     */
    modifier tokenIsNotListedForSale(uint256 tokenId) {
        if (s_tokenIdIsListedForSale[tokenId]) {
            revert DeCup__TokenIsListedForSale();
        }
        _;
    }

    /**
     * @notice Modifier to check if the token exists
     * @param tokenId The ID of the token to check
     * @dev Reverts if the token does not exist (no assets associated with it)
     */
    modifier tokenExists(uint256 tokenId) {
        if (ownerOf(tokenId) == address(0)) {
            revert DeCup__TokenDoesNotExist();
        }
        _;
    }

    // Functions
    /**
     * @notice Constructor to initialize the DeCup NFT contract with supported tokens and price feeds
     * @param _baseSvgImageUri Base URI for SVG images associated with NFTs
     * @param _tokenAddresses Array of ERC20 token addresses that can be used as collateral
     * @param _priceFeedAddresses Array of Chainlink price feed addresses corresponding to each token
     * @param _defaultPriceFeed The default price feed address for native currency (ETH)
     */
    constructor(string memory _baseSvgImageUri, address[] memory _tokenAddresses, address[] memory _priceFeedAddresses, address _defaultPriceFeed, string memory _defaultSymbol)
        ERC721("DeCup", "DCT")
        Ownable(msg.sender)
    {
        if (_tokenAddresses.length == 0) {
            revert DeCup__AllowedTokenAddressesMustNotBeEmpty();
        }

        if (_priceFeedAddresses.length == 0) {
            revert DeCup__PriceFeedAddressesMustNotBeEmpty();
        }

        if (_tokenAddresses.length != _priceFeedAddresses.length) {
            revert DeCup__TokenAddressesAndPriceFeedAddressesMusBeSameLength();
        }

        for (uint256 i; i < _tokenAddresses.length;) {
            s_tokenToPriceFeed[_tokenAddresses[i]] = _priceFeedAddresses[i];

            unchecked {
                ++i;
            }
        }

        s_tokenCounter = 0;
        s_svgImageUri = _baseSvgImageUri;
        s_defaultPriceFeed = _defaultPriceFeed;
        s_defaultSymbol = _defaultSymbol;
    }

    /*//////////////////////////////////////////////////////////////
                           EXTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Function to deposit native currency and mint a collateralized NFT
     * @dev This function is called when native currency is sent to the contract
     * @dev Implements the CEI pattern (Checks-Effects-Interactions)
     * @dev Uses nonReentrant modifier to prevent reentrancy attacks
     * @dev Emits DepositNativeCurrency event on successful deposit
     * @dev Mints a new NFT with tokenId equal to current tokenCounter
     * @dev Stores the native currency amount as collateral for the minted NFT
     * @dev Increments tokenCounter after successful mint
     * @dev Requires msg.value to be greater than zero (enforced by moreThanZero modifier)
     */
    receive() external payable moreThanZero(msg.value) nonReentrant {
        // Check (in modifiers)

        // Effect
        uint256 tokenId = s_tokenCounter;
        s_collateralDeposited[tokenId][address(0)] += msg.value;
        s_tokenIdToAssets[tokenId].push(address(0));
        emit DepositNativeCurrency(msg.sender, tokenId, msg.value);

        _safeMint(msg.sender, tokenId);
        s_tokenCounter++;

        //interact
    }

    /**
     * @notice Function to deposit an ERC20 token to an existing NFT as additional collateral
     * @param tokenAddress The ERC20 token contract address to deposit (must be a supported token with price feed)
     * @param amount The amount of tokens to deposit (must be greater than 0)
     * @param tokenId The ID of the existing NFT to add collateral to
     * @dev This function will transfer the specified amount of tokens from the caller to this contract
     * @dev Implements the CEI pattern (Checks-Effects-Interactions)
     * @dev Uses nonReentrant modifier to prevent reentrancy attacks
     * @dev Emits DepositERC20Token event on successful deposit
     * @dev The caller must have approved this contract to spend their tokens before calling this function
     */
    function addTokenCollateralToExistingCup(address tokenAddress, uint256 amount, uint256 tokenId)
        external
        isOwner(tokenId)
        tokenIsNotListedForSale(tokenId)
        moreThanZero(amount)
        nonReentrant
    {
        // Checkss
        if (s_tokenToPriceFeed[tokenAddress] == address(0)) {
            revert DeCup__NotAllowedToken();
        }
        // Effects
        if (s_collateralDeposited[tokenId][tokenAddress] == 0) {
            s_tokenIdToAssets[tokenId].push(tokenAddress);
        }
        s_collateralDeposited[tokenId][tokenAddress] += amount;
        emit DepositERC20Token(msg.sender, tokenId, tokenAddress, amount);

        // Interactions
        (bool success) = IERC20Metadata(tokenAddress).transferFrom(msg.sender, address(this), amount);
        if (!success) {
            revert DeCup__TransferFailed();
        }
    }

    /**
     * @notice Function to add native currency as collateral to an existing NFT
     * @param tokenId The ID of the existing NFT to add native currency collateral to
     * @dev This function is called when native currency is sent to add to an existing cup
     * @dev Implements the CEI pattern (Checks-Effects-Interactions)
     * @dev Uses moreThanZero modifier to ensure non-zero deposits
     * @dev Emits DepositNativeCurrency event on successful deposit
     * @dev If this is the first native currency deposit for this NFT, adds address(0) to tokenIdToAssets
     * @dev Requires msg.value to be greater than zero (enforced by moreThanZero modifier)
     * @dev Requires the NFT to exist (enforced by tokenId validation)
     */
    function addNativeCollateralToExistingCup(uint256 tokenId) external payable isOwner(tokenId) tokenIsNotListedForSale(tokenId) moreThanZero(msg.value) nonReentrant {
        if (s_collateralDeposited[tokenId][address(0)] == 0) {
            s_tokenIdToAssets[tokenId].push(address(0));
        }
        s_collateralDeposited[tokenId][address(0)] += msg.value;
        emit DepositNativeCurrency(msg.sender, tokenId, msg.value);
    }

    /**
     * @notice Function to deposit a single ERC20 token and mint an NFT collateralized by this token
     * @param tokenAddress The ERC20 token contract address to deposit (must be a supported token with price feed)
     * @param amount The amount of tokens to deposit (must be greater than 0)
     * @dev This function will transfer the specified amount of tokens from the caller to this contract
     * @dev Implements the CEI pattern (Checks-Effects-Interactions)
     * @dev Uses nonReentrant modifier to prevent reentrancy attacks
     * @dev Emits DepositERC20Token event on successful deposit
     * @dev The caller must have approved this contract to spend their tokens before calling this function
     */
    function depositSingleAssetAndMint(address tokenAddress, uint256 amount) external payable moreThanZero(amount) nonReentrant {
        // Checkss
        if (s_tokenToPriceFeed[tokenAddress] == address(0)) {
            revert DeCup__NotAllowedToken();
        }
        // Effects
        uint256 tokenId = s_tokenCounter;
        emit DepositERC20Token(msg.sender, tokenId, tokenAddress, amount);
        s_collateralDeposited[tokenId][tokenAddress] += amount;
        s_tokenIdToAssets[tokenId].push(tokenAddress);
        _mintAndIncreaseCounter(msg.sender, tokenId);

        // Interactionss
        (bool success) = IERC20Metadata(tokenAddress).transferFrom(msg.sender, address(this), amount);
        if (!success) {
            revert DeCup__TransferFailed();
        }
    }

    /**
     * @notice Function to deposit multiple ERC20 tokens and native currency, minting a single NFT collateralized by all assets
     * @param tokenAddresses Array of ERC20 token contract addresses to deposit as collateral
     * @param amounts Array of amounts to deposit for each corresponding token address
     * @dev Can also accept native currency via msg.value. If msg.value > 0, native currency will be included as collateral
     * @dev Implements the CEI pattern (Checks-Effects-Interactions)
     * @dev Uses nonReentrant modifier to prevent reentrancy attacks
     * @dev Emits DepositNativeCurrency and DepositERC20Token events for each successful deposit
     * @dev All token amounts must be greater than 0. Token addresses and amounts arrays must be same length
     * @dev The caller must have approved this contract to spend their tokens before calling this function
     * @dev Example usage:
     *   depositMultipleAssetsAndMint(
     *     [USDC_ADDRESS, DAI_ADDRESS],
     *     [1000e6, 1000e18],
     *     {value: 1e18} // 1 ETH
     *   )
     */
    function depositMultipleAssetsAndMint(address[] memory tokenAddresses, uint256[] memory amounts) external payable nonReentrant {
        // Checks (in modifiers)
        if (tokenAddresses.length != amounts.length) {
            revert DeCup__TokenAddressesAndAmountsMusBeSameLength();
        }

        if (tokenAddresses.length == 0 || amounts.length == 0) {
            revert DeCup__AmountMustBeGreaterThanZero();
        }

        // Effects / Interctions
        uint256 tokenId = s_tokenCounter;

        if (msg.value > 0) {
            emit DepositNativeCurrency(msg.sender, tokenId, msg.value);
            s_collateralDeposited[tokenId][address(0)] += msg.value;
            s_tokenIdToAssets[tokenId].push(address(0));
        }

        _mintAndIncreaseCounter(msg.sender, tokenId);

        uint256 length = tokenAddresses.length;
        for (uint256 i; i < length;) {
            if (amounts[i] == 0) {
                revert DeCup__AmountMustBeGreaterThanZero();
            }

            emit DepositERC20Token(msg.sender, tokenId, tokenAddresses[i], amounts[i]);
            s_collateralDeposited[tokenId][tokenAddresses[i]] += amounts[i];
            s_tokenIdToAssets[tokenId].push(tokenAddresses[i]);

            (bool success) = IERC20Metadata(tokenAddresses[i]).transferFrom(msg.sender, address(this), amounts[i]);
            if (!success) {
                revert DeCup__TransferFailed();
            }

            unchecked {
                ++i; // Use unchecked increment
            }
        }
    }

    /*//////////////////////////////////////////////////////////////
                           PUBLIC FUNCTIONSS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Function to list a token for sale
     * @param tokenId The ID of the token to list for sale
     * @param chainId The chain ID where the token is listed for sale
     * @dev Only callable by contract owner (manager)
     * @dev Emits TokenListedForSale event on successful listing
     * @dev Reverts if the token is already listed for sale
     */
    function listForSale(uint256 tokenId, uint256 chainId) public isManager tokenIsNotListedForSale(tokenId) {
        s_tokenIdIsListedForSale[tokenId] = true;
        s_tokenIdIsListedForSaleOnChain[tokenId] = chainId;
        emit TokenListedForSale(tokenId, chainId);
    }

    /**
     * @notice Function to remove a token from sale
     * @param tokenId The ID of the token to remove from sale
     * @dev Only callable by contract owner (manager)
     * @dev Emits TokenRemovedFromSale event on successful removal
     * @dev Reverts if the token is not listed for sale
     */
    function removeFromSale(uint256 tokenId) public isManager {
        if (!s_tokenIdIsListedForSale[tokenId]) {
            revert DeCup__TokenIsNotListedForSale();
        }
        s_tokenIdIsListedForSale[tokenId] = false;
        s_tokenIdIsListedForSaleOnChain[tokenId] = 0;
        emit TokenRemovedFromSale(tokenId);
    }

    /**
     * @notice Function to transfer a token by DeCupManager
     * @param tokenId The ID of the token to transfer
     * @param to The address to transfer the token to
     * @dev Implements the CEI pattern (Checks-Effects-Interactions)
     * @dev Uses nonReentrant modifier to prevent reentrancy attacks
     * @dev Only callable by contract owner (manager)
     * @dev Token must be listed for sale
     */
    function transfer(uint256 tokenId, address to) public tokenExists(tokenId) isManager tokenIsListedForSale(tokenId) nonReentrant returns (bool) {
        delete s_tokenIdIsListedForSale[tokenId];
        _transfer(ownerOf(tokenId), to, tokenId);
        return true;
    }

    /**
     * @notice Function to transfer a token and burn it by DeCupManager
     * @param tokenId The ID of the token to transfer and burn
     * @param to The address to transfer the token to
     * @dev Implements the CEI pattern (Checks-Effects-Interactions)
     * @dev Uses nonReentrant modifier to prevent reentrancy attacks
     * @dev Only callable by contract owner (manager)
     * @dev Token must be listed for sale
     */
    function transferAndBurn(uint256 tokenId, address to) public tokenExists(tokenId) isManager tokenIsListedForSale(tokenId) nonReentrant returns (bool) {
        delete s_tokenIdIsListedForSale[tokenId];
        emit TransferAndBurn(tokenId);
        _transfer(ownerOf(tokenId), to, tokenId);
        _withdraw(tokenId);
        _burn(tokenId);
        return true;
    }

    /**
     * @notice Burns the NFT and withdraws all collateral assets to the caller
     * @param tokenId The ID of the NFT to burn and withdraw collateral from
     * @dev Implements the CEI pattern (Checks-Effects-Interactions)
     * @dev Uses nonReentrant modifier to prevent reentrancy attacks
     * @dev Withdraws both native currency and ERC20 tokens if they were deposited as collateral
     * @dev Emits WithdrawNativeCurrency and WithdrawERC20Token events for each successful withdrawal
     * @dev Reverts if the token does not exist or if any transfer fails
     */
    function burn(uint256 tokenId) public override tokenExists(tokenId) isOwnerOrManager(tokenId) tokenIsNotListedForSale(tokenId) nonReentrant {
        emit Burn(tokenId);
        _withdraw(tokenId);
        _burn(tokenId);
    }

    /*//////////////////////////////////////////////////////////////
                           PRIVATE FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Internal function to mint a new token and increment the token counter
     * @param to The address to mint the token to
     * @param tokenId The ID of the token to mint
     * @dev Internal function used by deposit functions to mint NFTs
     * @dev Uses _safeMint to ensure the recipient can handle ERC721 tokens
     * @dev Increments s_tokenCounter after successful mint
     * @dev This function is called by depositSingleAssetAndMint and depositMultipleAssetsAndMint
     * @dev Ensures atomic minting and counter increment to prevent token ID conflicts
     */
    function _mintAndIncreaseCounter(address to, uint256 tokenId) private {
        _safeMint(to, tokenId);
        s_tokenCounter++;
    }

    /**
     * @notice Minimal uint256 to decimal string converter to avoid heavy imports
     */
    function _toString(uint256 value) private pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @notice Function to withdraw native currency
     * @param tokenId The ID of the NFT associated with the withdrawal
     * @param amount The amount of native currency to withdraw
     * @dev Internal function used by burn function to withdraw native currency
     * @dev Implements the CEI pattern (Checks-Effects-Interactions)
     * @dev Emits WithdrawNativeCurrency event on successful withdrawal
     * @dev Reverts if contract has insufficient balance or if transfer fails
     * @dev Funds are transferred to the owner of the NFT, not the caller
     */
    function _withdrawNativeCurrency(uint256 tokenId, uint256 amount) private {
        address owner = ownerOf(tokenId);
        if (address(this).balance < amount) {
            revert DeCup__InsufficientBalance();
        }

        s_collateralDeposited[tokenId][address(0)] = 0;
        emit WithdrawNativeCurrency(owner, amount);

        (bool success,) = address(payable(owner)).call{value: amount}("");
        if (!success) {
            revert DeCup__TransferFailed();
        }
    }

    /**
     * @notice Function to withdraw a single ERC20 token
     * @param tokenId The ID of the NFT associated with the withdrawal
     * @param tokenAddress The ERC20 token contract address to withdraw
     * @param amount The amount of tokens to withdraw
     * @dev Internal function used by burn function to withdraw ERC20 tokens
     * @dev Implements the CEI pattern (Checks-Effects-Interactions)
     * @dev Emits WithdrawERC20Token event on successful withdrawal
     * @dev Reverts if amount is zero (via moreThanZero modifier) or if transfer fails
     * @dev Reverts if contract has insufficient balance (via transfer check)
     * @dev Transfer function is called on the owner of the token
     */
    function _withdrawSingleToken(uint256 tokenId, address tokenAddress, uint256 amount) private moreThanZero(amount) {
        // Effect
        s_collateralDeposited[tokenId][tokenAddress] = 0;
        emit WithdrawERC20Token(ownerOf(tokenId), tokenAddress, amount);
        // Interaction
        if (!IERC20Metadata(tokenAddress).transfer(address(payable(ownerOf(tokenId))), amount)) {
            revert DeCup__TransferFailed();
        }
    }

    /**
     * @notice Function to withdraw all collateral assets from a token
     * @param tokenId The ID of the NFT to withdraw collateral from
     * @dev Internal function used by burn function to withdraw collateral assets
     * @dev Implements the CEI pattern (Checks-Effects-Interactions)
     * @dev Emits WithdrawNativeCurrency and WithdrawERC20Token events for each successful withdrawal
     */
    function _withdraw(uint256 tokenId) private {
        address[] memory assets = s_tokenIdToAssets[tokenId];
        delete s_tokenIdToAssets[tokenId];

        uint256 length = assets.length;
        for (uint256 i; i < length;) {
            if (assets[i] == address(0)) {
                _withdrawNativeCurrency(tokenId, s_collateralDeposited[tokenId][assets[i]]);
            } else {
                _withdrawSingleToken(tokenId, assets[i], s_collateralDeposited[tokenId][assets[i]]);
            }

            unchecked {
                ++i; // Use unchecked increment
            }
        }
    }

    /*//////////////////////////////////////////////////////////////
                INTERNAL / PRIVATE VIEW / PURE FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    // /**
    //  * @notice Returns the USD value of a given ETH token amount
    //  * @param tokenAddress The address of the ETH token
    //  * @param amount The amount of ETH tokens
    //  * @return The USD value of the given ETH token amount with additional precision
    //  * @dev Uses Chainlink price feeds to get real-time token prices
    //  * @dev Applies decimals conversion to maintain accuracy in calculations
    //  * @dev Multiplies by 10^10 to maintain precision in calculations
    //  * @dev Uses fixed 18 decimals for ETH (standard for native currency)
    //  * @dev Returns value in USD with 18 decimals of precision
    //  * @dev Note: Currently uses hardcoded 18 decimals, could be made dynamic in future versions
    //  */
    // function getEthUSDValue(address tokenAddress, uint256 amount) private view returns (uint256) {
    //     uint256 ethPrice = getUsdPrice(tokenAddress);
    //     return (ethPrice * PRECISION_MULTIPLIER) * amount / PRECISION_18;
    // }

    /**
     * @notice Returns the base URI for token metadata in base64 JSON format
     * @return The base URI string for token metadata
     * @dev Overrides the ERC721 _baseURI function to return a data URI
     * @dev Used by tokenURI function to construct the complete metadata URI
     */
    function _baseURI() internal pure override returns (string memory) {
        return "data:application/json;base64,";
    }

    /**
     * @notice Returns the USD value of a given token amount using Chainlink price feeds
     * @param tokenAddress The address of the ERC20 token to get the value for. Use address(0) for native currency
     * @return The USD value of the given token amount with additional precision
     * @dev Uses Chainlink price feeds to get real-time token prices
     * @dev Handles both native currency and ERC20 tokens
     * @dev Applies additional precision to maintain accuracy in calculations
     */
    function getUsdPrice(address tokenAddress) private view returns (uint256) {
        AggregatorV3Interface priceFeed;

        if (tokenAddress == address(0)) {
            priceFeed = AggregatorV3Interface(s_defaultPriceFeed);
        } else {
            priceFeed = AggregatorV3Interface(s_tokenToPriceFeed[tokenAddress]);
        }

        (, int256 price,,,) = priceFeed.latestRoundData();

        return uint256(price); //((uint256(price) * ADDITIONAL_FEED_PRECISION) * amount) / PRECISION;
    }

    /*//////////////////////////////////////////////////////////////
                EXTERNAL / PUBLIC VIEW / PURE FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Returns the list of assets deposited for a given token ID
     * @param tokenId The ID of the token to get the assets for
     * @return The list of assets deposited for the given token ID
     */
    function getAssetsInfo(uint256 tokenId) public view returns (string[] memory) {
        address[] memory tokenAddresses = s_tokenIdToAssets[tokenId];
        string[] memory symbols = new string[](tokenAddresses.length);

        for (uint256 i = 0; i < tokenAddresses.length;) {
            address tokenAddress = tokenAddresses[i]; // Cache array access
            uint256 amount = s_collateralDeposited[tokenId][tokenAddress];

            if (tokenAddress == address(0)) {
                symbols[i] = string(abi.encodePacked(s_defaultSymbol, " ", _toString(amount)));
            } else {
                uint256 decimals = IERC20Metadata(tokenAddress).decimals(); // Move declaration here
                uint256 scaledAmount = (amount * PRECISION_18) / (10 ** decimals);
                symbols[i] = string(abi.encodePacked(IERC20Metadata(tokenAddress).symbol(), " ", _toString(scaledAmount)));
            }

            unchecked {
                ++i;
            } // Use unchecked increment
        }
        return symbols;
    }

    /**
     * @notice Returns the listing status of a given token ID
     * @param tokenId The ID of the token to get the listing status for
     * @return The listing status of the given token ID
     */
    function getIsListedForSale(uint256 tokenId) public view returns (bool) {
        return s_tokenIdIsListedForSale[tokenId];
    }

    /**
     * @notice Returns the chain ID where the token is listed for sale
     * @param tokenId The ID of the token to get the chain ID for
     * @return The chain ID where the token is listed for sale
     */
    function getIsListedForSaleOnChain(uint256 tokenId) public view returns (uint256) {
        if (!s_tokenIdIsListedForSale[tokenId]) {
            revert DeCup__TokenIsNotListedForSale();
        }
        return s_tokenIdIsListedForSaleOnChain[tokenId];
    }

    /**
     * @notice Returns the USD value of a given USDC token amount
     * @param tokenAddress The address of the USDC token
     * @param amount The amount of USDC tokens
     * @return The USD value of the given USDC token amount with additional precision
     * @dev Uses Chainlink price feeds to get real-time token prices
     * @dev Applies decimals conversion to maintain accuracy in calculations
     * @dev Multiplies by 10^10 to maintain precision in calculations
     * @dev Handles token decimals dynamically using IERC20Metadata interface
     * @dev Returns value in USD with 18 decimals of precision
     */
    function getAssetValueInUsd(address tokenAddress, uint256 amount) public view returns (uint256) {
        uint256 usdcPrice = getUsdPrice(tokenAddress); //1000 0000 0000

        // 50 000 000 000 000 00000
        // 500 000 000 000 000 000
        // 500 000 000 000 000 000 000
        uint256 decimals = tokenAddress == address(0) ? ETH_DECIMALS : IERC20Metadata(tokenAddress).decimals();
        return (usdcPrice * PRECISION_MULTIPLIER) * amount / 10 ** decimals;
    }

    /**
     * @notice Returns the amount of collateral deposited for a given token ID and token address
     * @param tokenId The ID of the token to get the collateral for
     * @param tokenAddress The address of the token to get the collateral for
     * @return The amount of collateral deposited for the given token ID and token address
     */
    function getCollateralBalance(uint256 tokenId, address tokenAddress) public view returns (uint256) {
        return s_collateralDeposited[tokenId][tokenAddress];
    }

    /**
     * @notice Returns the total collateral value (TCL) for a given token ID in USD
     * @param tokenId The ID of the token to get the TCL for
     * @return The total collateral value (TCL) for the given token ID
     */
    function _getTokenIdTCL(uint256 tokenId) internal view returns (uint256) {
        address[] memory assets = s_tokenIdToAssets[tokenId];
        uint256 tcl = 0;
        for (uint256 i; i < assets.length;) {
            tcl += getAssetValueInUsd(assets[i], s_collateralDeposited[tokenId][assets[i]]);

            unchecked {
                ++i; // Use unchecked increment
            }
        }
        return tcl;
    }

    /**
     * @notice Returns the price of a token in USD with 8 decimals of precision
     * @param tokenId The ID of the token to get the price for
     * @return The price of the token in USD with 8 decimals of precision
     * @dev Converts TCL from 18 decimals to 8 decimals precision
     */
    function getTokenPriceInUsd(uint256 tokenId) public view returns (uint256) {
        if (ownerOf(tokenId) == address(0)) {
            revert DeCup__TokenDoesNotExist();
        }

        uint256 tcl = _getTokenIdTCL(tokenId); //retuns in 18 decimals

        return (tcl * PRECISION_8) / PRECISION_18; //convert to 8 decimals
    }

    /**
     * @notice Returns the token counter
     * @return The token counter
     */
    function getTokenCounter() public view returns (uint256) {
        return s_tokenCounter;
    }

    /**
     * @notice Returns the metadata URI for a given token ID in base64 JSON format
     * @param _tokenId The ID of the token to get metadata for
     * @return A base64 encoded JSON string containing the token's metadata
     * @dev Optimized version with reduced bytecode size and gas usage
     */
    function tokenURI(uint256 _tokenId) public view override returns (string memory) {
        address[] memory assets = s_tokenIdToAssets[_tokenId];

        // Pre-calculate TCL and build attributes in single pass
        uint256 tcl;
        bytes memory attributes;

        // Cache tokenId string to avoid repeated conversion
        string memory tokenIdStr = _toString(_tokenId);

        for (uint256 i; i < assets.length;) {
            address asset = assets[i]; // Cache asset address
            uint256 amount = s_collateralDeposited[_tokenId][asset];

            // Calculate USD value and add to TCL
            uint256 usdValue = getAssetValueInUsd(asset, amount);
            tcl += usdValue;

            // Get symbol once
            string memory symbol = asset == address(0) ? s_defaultSymbol : IERC20Metadata(asset).symbol();

            // Build attribute JSON more efficiently
            attributes = abi.encodePacked(attributes, i > 0 ? bytes(",") : bytes(""), '{"trait_type":"', symbol, '","value":"', _toString(amount), '"}');

            unchecked {
                ++i;
            }
        }

        // Convert TCL to display format
        tcl = tcl / PRECISION_18;
        string memory tclStr = _toString(tcl);

        // Build complete JSON in single abi.encodePacked call
        return string(
            abi.encodePacked(
                _baseURI(),
                Base64.encode(
                    abi.encodePacked(
                        '{"tokenId":"',
                        tokenIdStr,
                        '","name":"',
                        name(),
                        " #",
                        tokenIdStr,
                        " $",
                        tclStr,
                        '","description":"Decentralized Cup of assets","attributes":[',
                        '{"trait_type":"TCL","value":"',
                        tclStr,
                        ' USD"}',
                        attributes.length > 0 ? "," : "",
                        attributes,
                        '],"image":"',
                        s_svgImageUri,
                        '"}'
                    )
                )
            )
        );
    }
}

// Layout of Contract:
// version
// imports
// interfaces, libraries, contracts
// errors
// Type declarations
// State variables
// Events
// Modifiers
// Functions

// Layout of Functions:
// constructor
// receive function (if exists)
// fallback function (if exists)
// external
// public
// internal
// private
// internal & private view & pure functions
// external & public view & pure functions

// CEI:
// Check
// Effect
// Interaction
